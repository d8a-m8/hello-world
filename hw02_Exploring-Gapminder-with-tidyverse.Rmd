---
title: "Gapminder Unwinder: Hwk_2"
author: "_d8a-m8_ a.k.a. _delta thru data_ a.k.a Yevgen '_the d8a nonh8a_' Kovalenko"
date: "`r format (Sys.Date())`"
output: github_document
##yamal front matter 

---

## Minder the Gap. The door's are now closing.

Welcome! This should be a fun ride today for you and I. So in this following report we will be exploring the Gapminder dataset...however, I will have no idea what you will end up seeing.

So, get some coffee or tea or any consumable, potable liquid %>% temperature(hot:cold) and let's get started. :D

```{r Setup, include=F}
knitr::opts_chunk$set(echo=TRUE) #above: hides this chunk, inline:sets all chunks to be viewed globally

#Selfnote: %>% pipe operator fucn(arg1,arg2...) v. arg1 %>% func(arg2....)

library('gapminder')
library('tibble')
library('tidyverse')
library('ggplot2')
```

Why?

```{r Present -Random- Package}
library("random")
```

That's why. I will be using the _random_ package to make this interesting. Let's explore the relationship between life expectancy as a function of GDP per capita. (_You will need internet connection to run some of this code. Especially pertaining to the **random** functions._)

Initially, let us see what we are working with before any _~CrA~_ _Z_ _~~~~ neSS ~~~~_.

```{r Explore feactures of gapminder with str function}
str(gapminder)  

#Exploring tbl.df of gapminder, also could have formatted the script as in Chuck 4 (Summary)
```

As expected this dataset is a tbl = tibble dataframe. Buckets of observations (1704) of the six tracked variables: country(factor), continent(factor), year(integer), life expectancy(double/float), population(integer), GDP per capita(double/float). We can also see there were 152 surveyed countries on all **five** continents.

_~looking~ ~at~ ~you~ **~ANTarctica~**_

To be clear, Gapminder is a tibble dataframe with 1704 rows of observations catergorized by six columns of factors/variables. These variables and the corresponding flavours are listed above.

Apart from using str(), simply typing the object name would provide that data following "#A tibble: ...". 

Using the summary function, we can look at the basic statistical data of this dataframe. In particular, let us only consider the year, life expectancy, population, and GDP.

```{r Summary}
gapminder[,3:6] %>% 
  summary()
```

Here we can see the global maximums and minimums of all four quantitative data, in addition to the first and third quartiles, the median, and the mean. Let's only consider life expectancy and GDP for now with respect to countries and continents.

Here are some histograms (the facetted plots will be density plots, since density > histogram) of these two variables without respect to continent or country.

```{r Histograms}
p_hist <- gapminder %>% 
  ggplot()

p_hist + geom_histogram(aes(x = lifeExp), alpha = 0.5, binwidth = 5)
p_hist + geom_histogram(aes(x = gdpPercap),alpha = 0.5, binwidth = 10000)
```

With respect to continents? ~(~ ~countries~ ~would~ ~be~ ~crazy~ ~)~

```{r Density Plots1}
p_hist + facet_wrap(~ continent) + geom_density(aes(x = lifeExp), alpha = 0.5) 
```

```{r Density Plots2}
p_hist + facet_wrap(~ continent) + geom_density(aes(x = gdpPercap), alpha = 0.5)
```

So, what do we see here? Well, for life expectancy Americas, Asia, Europe, and Oceania have left-skewed distributions. Africa has a right-skewed distribution. As for GDP, all continents are right-skewed for GDP per capita.

Can we say anything about the relationship between these two variables? _No._ In order to talk about this we must plot **MORE GRAPHS** !!!

## Investigation of Socio-Ecomonics in Gapminder

Now let's look at the exact same parameters as before and dive into how GDP and life expectancy correlate. _~(~ ~Now~ ~with~ ~ggplots~ ~and~ ~dplyr~ ~)~_

```{r Plot L v. G data}
pt_lvg <- gapminder %>% 
  ggplot()

#Making plot space

pt_lvg + geom_point(aes(x = gdpPercap, y = lifeExp, colour = continent)) + geom_smooth(aes(x = gdpPercap, y = lifeExp))

#Assigning points
```

Let's plot this on a different scale.

```{r Replot}

pt_lvg + geom_point(aes(x = log10(gdpPercap), y = log10(lifeExp), colour = continent)) + geom_smooth(aes(x = log10(gdpPercap), y = log10(lifeExp)))

#or I could have added "+ scale_x_log10()" instead of two log10() :/
```

Really interesting. There does appear to be some linear correlation, particularly in the middle of the plot, but the correlation breaks down at the fringes. Possibly due to unknown, unconsidered factors.

Let's check the correlation between these two variables.

~~ Pearson's Correlation Coefficient & Coefficient of Determination~~

```{r !!!Correlations!!!}
r_p <- with(gapminder, cor(log10(gdpPercap), log10(lifeExp))) #Assigning object that is the P.C.C. of lifeExp and GDP

r_p #Pearson's C.C. (P.C.C.)

r_p^2 #Coefficent of determination
```

As seen above, there is some correlation between life expectancy and GDP per capita. Perhaps this is trivial because as GDP per capita increases, it could be said that quality of life also increases and thus, perhaps life expectancy. Although this clearly does not paint the complete picture (R = 0.783, R<sup>2</sup> = 0.613) as the other factors will affect both that may or may not affect the other. 

```{r Modelling, include = F}
# Modelling L v. G as Michaelis-Menten kinetics :D

x <- c(as.matrix(gapminder['gdpPercap']))
y <- c(as.matrix(gapminder['lifeExp']))
fitModel <- nls(y ~ (a * x) / (b + x), start=list(a=1, b=0.5))
params = coef(fitModel)
m.x <- sort(x, decreasing = F)
m.y <- (params['a'] * m.x) / (params['b'] + m.x)
model.p <- gapminder %>% 
  ggplot()
model.p + geom_point(aes(x = gdpPercap, y = lifeExp, colour = continent)) + geom_smooth(aes(x = m.x, y = m.y, xend = 1800, yend = 100))

#Turns out people aren't exactly like enzyme kinetics...hmmm. My major assumption is human age maxes out at some point here. seems more like two intersecting lines to me now....
```

Back to business.

The above trends may reflect the socio-economic status of a continent as life expectancy can be seen to correlate with GDP. Let's take a look to see if this trend holds up for different places. Let us make an arbitrary decision on which countries to investigate. _INCOMING: random data retreiver_

```{r Random Country List Generator}
country_names <- unique(gapminder['country'])

rand.lett <- randomStrings(n=1,len=1,digits=F)
print(rand.lett)

cnm <- grep(
  as.list(rand.lett), 
  as.matrix(country_names[,1]))

name.list <- country_names[cnm,]

print(name.list)

# @ this point, all I have done is made of list of all the unique names of countries in gapminder. I proceed to grab all countries within that list that start with a randomly selected letter. A tibble of said countries is made "name.list". Then the script prints the list.

new_gp <- gapminder %>% 
  filter(country %in% c(as.matrix(name.list)))

new_gp_data <- new_gp %>% 
  select(lifeExp, gdpPercap)
  
print(new_gp)
print(new_gp_data)

# Here is the good part well, the important one. A new gapminder "new_gp" data set is filtered by all the names in the name.list. New_gp_data is created by selecting for GDP and life expectancy to ease calculations.
```

Now if you're still here. We have one more thing to do. I hope it's not too crazy. 

Note: this will not work if you lack internet connection. Also, it may take some time depending on the performance capabilities of your computer. Sorry for computers with little RAM and/or

```{r Nice plot to finish off.}
p_ngp <- new_gp %>% 
  ggplot()

p_ngp + geom_point(aes(x = gdpPercap, y = lifeExp)) + geom_smooth(aes(x = gdpPercap, y = lifeExp)) + scale_x_log10() + facet_wrap(~ country)

r.p <- new_gp_data %>% 
  with(cor(log10(gdpPercap), log10(lifeExp))) 

#Assigning object that is the P.C.C. of lifeExp and GDP

r.p #Pearson's C.C. (P.C.C.)

r.p^2 #Coefficent of determination
```

Now if this works as intended, you will have a "unique" letter from print(rand.lett) and list of countries with associated graphs and correlation coffiecients.

If you can handle reading these nearly 200 lines of code, I applaud you. I got tired just typing this all out!

To show that you truly got to this point, please include your print(rand.lett) and correlation coffiecient results in your review of my work.

_CHEERS!_